using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using MultiCom.Shared.Audio;
using MultiCom.Client.Audio;
using NAudio.Wave;
using Touchless.Vision.Camera;

namespace MultiCom.Client
{
    public partial class ClientForm : Form
    {
        private const string MULTICAST_IP = "224.0.0.1";
        private const int VIDEO_PORT = 8080;
        private const int AUDIO_PORT = 8081;
        private const int CHAT_PORT = 8082;
        private const int TARGET_WIDTH = 320;
        private const int TARGET_HEIGHT = 240;

        private readonly Guid clientId = Guid.NewGuid();
        private readonly List<Camera> availableCameras = new List<Camera>();
        private readonly Dictionary<string, PictureBox> videoTiles = new Dictionary<string, PictureBox>();
        
        private CameraFrameSource frameSource;
        private Bitmap myLatestFrame;
        private string displayName = "User";
        private bool isConnected;
        
        private WaveInEvent waveIn;
        private UdpClient audioSender;
        private IPEndPoint audioEndPoint;
        
        private UdpClient videoReceiver;
        private UdpClient audioReceiver;
        private UdpClient chatReceiver;
        private UdpClient chatSender;
        
        private Task videoTask;
        private Task audioTask;
        private Task chatTask;
        private CancellationTokenSource cts;
        
        private SimpleAudioPlayer audioPlayer;

        public ClientForm()
        {
            InitializeComponent();
            this.Load += OnClientLoaded;
            this.FormClosing += OnFormClosing;
        }

        private void OnClientLoaded(object sender, EventArgs e)
        {
            ApplyDiscordPalette();
            LoadCameras();
            lblProfileName.Text = $"Signed in as {displayName}";
            btnDisconnect.Enabled = false;
            Log("[INFO] Ready. Press Connect to join.");
        }

        private void ApplyDiscordPalette()
        {
            this.BackColor = Color.FromArgb(54, 57, 63);
            btnSendMessage.BackColor = Color.FromArgb(88, 101, 242);
            btnToggleCamera.BackColor = Color.FromArgb(67, 181, 129);
            btnConnect.BackColor = Color.FromArgb(67, 181, 129);
            btnSettings.BackColor = Color.FromArgb(88, 101, 242);
        }

        private void LoadCameras()
        {
            availableCameras.Clear();
            foreach (Camera cam in CameraService.AvailableCameras)
            {
                availableCameras.Add(cam);
            }
            UpdateCameraButtonState();
        }

        private void UpdateCameraButtonState()
        {
            bool hasCam = availableCameras.Count > 0 || frameSource != null;
            btnToggleCamera.Enabled = hasCam && isConnected;
            btnToggleCamera.Text = frameSource != null ? "Disable camera" : "Enable camera";
            btnToggleCamera.BackColor = frameSource != null ? Color.FromArgb(240, 71, 71) : Color.FromArgb(67, 181, 129);
        }

        private void OnConnect(object sender, EventArgs e)
        {
            if (isConnected) return;

            try
            {
                isConnected = true;
                btnConnect.Enabled = false;
                btnDisconnect.Enabled = true;
                cts = new CancellationTokenSource();

                chatSender = new UdpClient();
                
                videoTask = Task.Run(() => ReceiveVideoLoop(), cts.Token);
                audioTask = Task.Run(() => ReceiveAudioLoop(), cts.Token);
                chatTask = Task.Run(() => ReceiveChatLoop(), cts.Token);

                Log("[INFO] Connected to MultiCom.");
                UpdateCameraButtonState();
            }
            catch (Exception ex)
            {
                Log("[ERROR] Connect failed: " + ex.Message);
                OnDisconnect(null, null);
            }
        }

        private void OnDisconnect(object sender, EventArgs e)
        {
            if (!isConnected) return;

            try
            {
                isConnected = false;
                cts?.Cancel();

                StopCamera();
                StopAudio();

                Thread.Sleep(100);

                videoReceiver?.Close();
                audioReceiver?.Close();
                chatReceiver?.Close();
                chatSender?.Close();

                videoReceiver = null;
                audioReceiver = null;
                chatReceiver = null;
                chatSender = null;

                cts?.Dispose();
                cts = null;

                ClearVideoTiles();
                
                btnConnect.Enabled = true;
                btnDisconnect.Enabled = false;
                UpdateCameraButtonState();
                
                Log("[INFO] Disconnected.");
            }
            catch (Exception ex)
            {
                Log("[ERROR] Disconnect: " + ex.Message);
            }
        }

        private void OnToggleCamera(object sender, EventArgs e)
        {
            if (frameSource != null)
            {
                StopCamera();
            }
            else
            {
                StartCamera();
            }
        }

        private void StartCamera()
        {
            if (availableCameras.Count == 0 || !isConnected) return;

            try
            {
                frameSource = new CameraFrameSource(availableCameras[0]);
                frameSource.Camera.CaptureWidth = TARGET_WIDTH;
                frameSource.Camera.CaptureHeight = TARGET_HEIGHT;
                frameSource.Camera.Fps = 15;
                frameSource.NewFrame += OnCameraFrame;
                frameSource.StartFrameCapture();
                
                StartAudio();
                UpdateCameraButtonState();
                Log("[INFO] Camera enabled.");
            }
            catch (Exception ex)
            {
                Log("[ERROR] Camera start: " + ex.Message);
                StopCamera();
            }
        }

        private void StopCamera()
        {
            if (frameSource != null)
            {
                frameSource.NewFrame -= OnCameraFrame;
                frameSource.StopFrameCapture();
                frameSource = null;
            }

            StopAudio();
            UpdateCameraButtonState();
        }

        private void StartAudio()
        {
            try
            {
                audioSender = new UdpClient();
                audioEndPoint = new IPEndPoint(IPAddress.Parse(MULTICAST_IP), AUDIO_PORT);

                waveIn = new WaveInEvent();
                waveIn.DeviceNumber = 0;
                waveIn.WaveFormat = new WaveFormat(8000, 16, 1);
                waveIn.BufferMilliseconds = 50;
                waveIn.DataAvailable += OnAudioCaptured;
                waveIn.StartRecording();
            }
            catch (Exception ex)
            {
                Log("[ERROR] Audio start: " + ex.Message);
            }
        }

        private void StopAudio()
        {
            waveIn?.StopRecording();
            waveIn?.Dispose();
            waveIn = null;
            audioSender?.Close();
            audioSender = null;
        }

        private void OnAudioCaptured(object sender, WaveInEventArgs e)
        {
            try
            {
                byte[] encoded = ALawEncoder.ALawEncode(e.Buffer);
                audioSender.Send(encoded, encoded.Length, audioEndPoint);
            }
            catch (Exception ex)
            {
                Log("[ERROR] Audio send: " + ex.Message);
            }
        }

        private void OnCameraFrame(Touchless.Vision.Contracts.IFrameSource source, 
                                   Touchless.Vision.Contracts.Frame frame, double fps)
        {
            try
            {
                myLatestFrame = (Bitmap)frame.Image.Clone();
                RenderMyVideo();
                BroadcastFrame(myLatestFrame);
            }
            catch (Exception ex)
            {
                Log("[ERROR] Frame capture: " + ex.Message);
            }
        }

        private void RenderMyVideo()
        {
            if (myLatestFrame == null) return;

            try
            {
                BeginInvoke(new Action(() =>
                {
                    string tileKey = "ME_" + clientId.ToString();
                    PictureBox pb;
                    if (!videoTiles.TryGetValue(tileKey, out pb))
                    {
                        pb = CreateVideoTile(displayName);
                        videoTiles[tileKey] = pb;
                        flowVideo.Controls.Add(pb);
                    }

                    if (pb.Image != null) pb.Image.Dispose();
                    pb.Image = new Bitmap(myLatestFrame, new Size(TARGET_WIDTH, TARGET_HEIGHT));
                }));
            }
            catch { }
        }

        private void BroadcastFrame(Bitmap bitmap)
        {
            if (bitmap == null) return;

            Task.Run(() =>
            {
                try
                {
                    using (var udpServer = new UdpClient())
                    {
                        IPAddress multicastaddress = IPAddress.Parse(MULTICAST_IP);
                        udpServer.JoinMulticastGroup(multicastaddress);
                        IPEndPoint remote = new IPEndPoint(multicastaddress, VIDEO_PORT);

                        uint imageNumber = (uint)Environment.TickCount;
                        long timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();

                        byte[] jpegData = ImageToByteArray(bitmap);
                        using (MemoryStream ms = new MemoryStream())
                        {
                            ms.Write(BitConverter.GetBytes(imageNumber), 0, 4);
                            ms.Write(BitConverter.GetBytes(timestamp), 0, 8);
                            ms.Write(jpegData, 0, jpegData.Length);

                            byte[] paquete = ms.ToArray();
                            udpServer.Send(paquete, paquete.Length, remote);
                            
                            Log($"[DEBUG] Sent video packet, size: {paquete.Length}");
                        }
                    }
                }
                catch (Exception ex)
                {
                    Log("[ERROR] Video send: " + ex.Message);
                }
            });
        }

        private byte[] ImageToByteArray(Image imageIn)
        {
            using (var ms = new MemoryStream())
            {
                imageIn.Save(ms, ImageFormat.Jpeg);
                return ms.ToArray();
            }
        }

        private void ReceiveVideoLoop()
        {
            try
            {
                videoReceiver = new UdpClient();
                IPAddress multicastaddress = IPAddress.Parse(MULTICAST_IP);
                videoReceiver.JoinMulticastGroup(multicastaddress);

                IPEndPoint remoteep = new IPEndPoint(IPAddress.Any, VIDEO_PORT);
                videoReceiver.Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
                videoReceiver.Client.Bind(remoteep);

                Log("[INFO] Video receiver started on port " + VIDEO_PORT);

                while (!cts.Token.IsCancellationRequested)
                {
                    byte[] paquete = videoReceiver.Receive(ref remoteep);
                    if (paquete.Length <= 12) continue;

                    uint imageNumber = BitConverter.ToUInt32(paquete, 0);
                    long timestampEmisor = BitConverter.ToInt64(paquete, 4);

                    byte[] jpeg = new byte[paquete.Length - 12];
                    Array.Copy(paquete, 12, jpeg, 0, jpeg.Length);

                    Log($"[DEBUG] Received video packet from {remoteep.Address}, size: {paquete.Length}");

                    using (var ms = new MemoryStream(jpeg))
                    {
                        Bitmap bitmap = new Bitmap(ms);
                        string sender = remoteep.Address.ToString();
                        RenderRemoteVideo(sender, bitmap);
                    }
                }
            }
            catch (ObjectDisposedException) { }
            catch (SocketException ex)
            {
                if (!cts.Token.IsCancellationRequested)
                    Log("[ERROR] Video receive: " + ex.Message);
            }
            catch (Exception ex)
            {
                Log("[ERROR] Video loop: " + ex.Message);
            }
        }

        private void RenderRemoteVideo(string sender, Bitmap bitmap)
        {
            try
            {
                BeginInvoke(new Action(() =>
                {
                    string tileKey = "REMOTE_" + sender;
                    PictureBox pb;
                    if (!videoTiles.TryGetValue(tileKey, out pb))
                    {
                        pb = CreateVideoTile(sender);
                        videoTiles[tileKey] = pb;
                        flowVideo.Controls.Add(pb);
                    }

                    if (pb.Image != null) pb.Image.Dispose();
                    pb.Image = new Bitmap(bitmap, new Size(TARGET_WIDTH, TARGET_HEIGHT));
                }));
            }
            catch { }
        }

        private PictureBox CreateVideoTile(string caption)
        {
            var pb = new PictureBox
            {
                BackColor = Color.Black,
                Size = new Size(220, 180),
                SizeMode = PictureBoxSizeMode.Zoom,
                Margin = new Padding(8)
            };
            return pb;
        }

        private void ClearVideoTiles()
        {
            try
            {
                BeginInvoke(new Action(() =>
                {
                    foreach (var pb in videoTiles.Values)
                    {
                        if (pb.Image != null) pb.Image.Dispose();
                        pb.Dispose();
                    }
                    videoTiles.Clear();
                    flowVideo.Controls.Clear();
                }));
            }
            catch { }
        }

        private void ReceiveAudioLoop()
        {
            try
            {
                audioReceiver = new UdpClient();
                audioReceiver.Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
                IPEndPoint audioEP = new IPEndPoint(IPAddress.Any, AUDIO_PORT);
                audioReceiver.Client.Bind(audioEP);
                audioReceiver.JoinMulticastGroup(IPAddress.Parse(MULTICAST_IP));

                audioPlayer = new SimpleAudioPlayer();
                audioPlayer.Start();

                Log("[INFO] Audio receiver started on port " + AUDIO_PORT);

                while (!cts.Token.IsCancellationRequested)
                {
                    byte[] alaw = audioReceiver.Receive(ref audioEP);
                    short[] decoded = ALawDecoder.ALawDecode(alaw);

                    byte[] pcm = new byte[decoded.Length * 2];
                    Buffer.BlockCopy(decoded, 0, pcm, 0, pcm.Length);

                    audioPlayer.AddSamples(pcm, 0, pcm.Length);
                }
            }
            catch (ObjectDisposedException) { }
            catch (SocketException ex)
            {
                if (!cts.Token.IsCancellationRequested)
                    Log("[ERROR] Audio receive: " + ex.Message);
            }
            catch (Exception ex)
            {
                Log("[ERROR] Audio loop: " + ex.Message);
            }
            finally
            {
                audioPlayer?.Dispose();
                audioPlayer = null;
            }
        }

        private void ReceiveChatLoop()
        {
            try
            {
                chatReceiver = new UdpClient(CHAT_PORT);
                chatReceiver.JoinMulticastGroup(IPAddress.Parse(MULTICAST_IP));
                chatReceiver.Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
                IPEndPoint chatEP = new IPEndPoint(IPAddress.Any, CHAT_PORT);

                while (!cts.Token.IsCancellationRequested)
                {
                    byte[] buffer = chatReceiver.Receive(ref chatEP);
                    string mensaje = Encoding.Unicode.GetString(buffer);

                    BeginInvoke(new Action(() =>
                    {
                        listChat.Items.Add($"[{DateTime.Now:HH:mm}] {mensaje}");
                        if (listChat.Items.Count > 200) listChat.Items.RemoveAt(0);
                        if (listChat.Items.Count > 0) listChat.TopIndex = listChat.Items.Count - 1;
                    }));
                }
            }
            catch (ObjectDisposedException) { }
            catch (SocketException ex)
            {
                if (!cts.Token.IsCancellationRequested)
                    Log("[ERROR] Chat receive: " + ex.Message);
            }
            catch (Exception ex)
            {
                Log("[ERROR] Chat loop: " + ex.Message);
            }
        }

        private void OnSendMessage(object sender, EventArgs e)
        {
            SendChat();
        }

        private void OnMessageKeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Enter && !e.Shift)
            {
                e.Handled = true;
                e.SuppressKeyPress = true;
                SendChat();
            }
        }

        private void SendChat()
        {
            string texto = txtMessage.Text.Trim();
            if (string.IsNullOrEmpty(texto) || !isConnected) return;

            try
            {
                byte[] datos = Encoding.Unicode.GetBytes($"{displayName}: {texto}");
                chatSender.Send(datos, datos.Length, new IPEndPoint(IPAddress.Parse(MULTICAST_IP), CHAT_PORT));

                BeginInvoke(new Action(() =>
                {
                    listChat.Items.Add($"[{DateTime.Now:HH:mm}] You: {texto}");
                    if (listChat.Items.Count > 200) listChat.Items.RemoveAt(0);
                    if (listChat.Items.Count > 0) listChat.TopIndex = listChat.Items.Count - 1;
                    txtMessage.Clear();
                }));
            }
            catch (Exception ex)
            {
                Log("[ERROR] Chat send: " + ex.Message);
            }
        }

        private void OnSettings(object sender, EventArgs e)
        {
            string newName = Microsoft.VisualBasic.Interaction.InputBox("Enter your name:", "Settings", displayName);
            if (!string.IsNullOrWhiteSpace(newName))
            {
                displayName = newName;
                lblProfileName.Text = $"Signed in as {displayName}";
            }
        }

        private void OnOpenSettings(object sender, EventArgs e)
        {
            OnSettings(sender, e);
        }

        private void OnUiTimerTick(object sender, EventArgs e)
        {
            // Actualizar mÃ©tricas si es necesario
        }

        private void Log(string message)
        {
            try
            {
                BeginInvoke(new Action(() =>
                {
                    listDiagnostics.Items.Add($"[{DateTime.Now:HH:mm:ss}] {message}");
                    if (listDiagnostics.Items.Count > 100) listDiagnostics.Items.RemoveAt(0);
                    if (listDiagnostics.Items.Count > 0) listDiagnostics.TopIndex = listDiagnostics.Items.Count - 1;
                }));
            }
            catch { }
        }

        private void OnFormClosing(object sender, FormClosingEventArgs e)
        {
            OnDisconnect(null, null);
        }
    }
}
