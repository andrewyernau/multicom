using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using MultiCom.Shared.Networking;

namespace MultiCom.Server
{
    public partial class ServerForm : Form
    {
        private readonly object rosterGate = new object();
        private readonly Dictionary<Guid, PresenceRecord> roster = new Dictionary<Guid, PresenceRecord>();
        private readonly Dictionary<Guid, IPEndPoint> clientEndpoints = new Dictionary<Guid, IPEndPoint>();
        private readonly SemaphoreSlim snapshotLock = new SemaphoreSlim(1, 1);
        private readonly IPEndPoint controlEndpoint = MulticastChannels.BuildControlEndpoint();
        private CancellationTokenSource presenceToken;
        private Task presenceTask;
        private UdpClient snapshotSender;
        private DateTime lastSnapshotUtc = DateTime.MinValue;
        private int snapshotsBroadcast;
        private CancellationTokenSource relayToken;
        private Task videoRelayTask;
        private Task chatRelayTask;
        private Task audioRelayTask;
        private UdpClient videoRelayReceiver;
        private UdpClient chatRelayReceiver;
        private UdpClient audioRelayReceiver;
        private UdpClient videoRelaySender;
        private UdpClient chatRelaySender;
        private UdpClient audioRelaySender;

        public ServerForm()
        {
            InitializeComponent();
        }

        private void OnFormLoaded(object sender, EventArgs e)
        {
            ApplyDiscordPalette();
            StartPresenceService();
            streamingTimer.Start();
        }

        private void ApplyDiscordPalette()
        {
            btnStart.FlatAppearance.MouseOverBackColor = Color.FromArgb(114, 137, 218);
            btnStop.FlatAppearance.BorderColor = Color.FromArgb(114, 118, 125);
            btnStop.FlatAppearance.MouseOverBackColor = Color.FromArgb(80, 82, 90);
            btnRefreshCamera.FlatAppearance.BorderColor = Color.FromArgb(114, 118, 125);
            btnRefreshCamera.FlatAppearance.MouseOverBackColor = Color.FromArgb(80, 82, 90);
        }

        private async void OnRefreshCameraClick(object sender, EventArgs e)
        {
            await BroadcastSnapshotAsync();
        }

        private void OnStartStreaming(object sender, EventArgs e)
        {
            StartPresenceService();
        }

        private void OnStopStreaming(object sender, EventArgs e)
        {
            StopPresenceService();
        }

        private void StopPresenceService()
        {
            if (presenceToken == null)
            {
                return;
            }

            presenceToken.Cancel();
            StopRelayServices();

            if (snapshotSender != null)
            {
                try
                {
                    snapshotSender.Close();
                    snapshotSender.Dispose();
                }
                catch
                {
                }
                snapshotSender = null;
            }
            
            if (presenceTask != null && !presenceTask.IsCompleted)
            {
                presenceTask.Wait(50);
            }

            presenceTask = null;
            presenceToken.Dispose();
            presenceToken = null;

            lock (rosterGate)
            {
                roster.Clear();
                clientEndpoints.Clear();
            }

            snapshotsBroadcast = 0;
            lastSnapshotUtc = DateTime.MinValue;
            UpdateRosterList();
            UpdateMetrics();
            Log("[INFO] Presence service stopped.");
        }

        private void StartPresenceService()
        {
            if (presenceToken != null)
            {
                Log("[WARN] Presence service already running.");
                return;
            }

            presenceToken = new CancellationTokenSource();
            presenceTask = Task.Run(() => ListenPresenceLoop(presenceToken.Token));
            snapshotSender = new UdpClient(AddressFamily.InterNetwork);
            snapshotSender.ExclusiveAddressUse = false;
            snapshotSender.MulticastLoopback = true;
            snapshotSender.Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
            snapshotSender.Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Broadcast, true);
            snapshotSender.Client.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.MulticastTimeToLive, 32);
            snapshotSender.Client.Bind(new IPEndPoint(IPAddress.Any, 0));
            snapshotSender.JoinMulticastGroup(controlEndpoint.Address);
            lock (rosterGate)
            {
                roster.Clear();
            }

            snapshotsBroadcast = 0;
            lastSnapshotUtc = DateTime.MinValue;
            UpdateRosterList();
            UpdateMetrics();
            StartRelayServices();
            Log("[INFO] Presence service started.");
            var _ = BroadcastSnapshotAsync();
        }

        private void ListenPresenceLoop(CancellationToken token)
        {
            var endpoint = MulticastChannels.BuildControlEndpoint();
            using (var udp = CreateMulticastListener(endpoint))
            {
                udp.JoinMulticastGroup(endpoint.Address);
                udp.Client.ReceiveTimeout = 1000;
                var remote = new IPEndPoint(IPAddress.Any, endpoint.Port);
                while (!token.IsCancellationRequested)
                {
                    byte[] buffer;
                    IPEndPoint clientEndpoint;
                    try
                    {
                        buffer = udp.Receive(ref remote);
                        clientEndpoint = new IPEndPoint(remote.Address, 0);
                    }
                    catch (SocketException ex)
                    {
                        if (ex.SocketErrorCode == SocketError.TimedOut)
                        {
                            continue;
                        }

                        Log("[ERROR] Control loop: " + ex.Message);
                        continue;
                    }
                    catch (ObjectDisposedException)
                    {
                        break;
                    }

                    PresenceMessage message;
                    if (!PresenceMessage.TryParse(buffer, out message))
                    {
                        continue;
                    }

                    if (message.Kind == PresenceOpcode.Snapshot)
                    {
                        continue;
                    }

                    lock (rosterGate)
                    {
                        if (message.Kind != PresenceOpcode.Goodbye)
                        {
                            clientEndpoints[message.ClientId] = clientEndpoint;
                        }
                        else
                        {
                            clientEndpoints.Remove(message.ClientId);
                        }
                    }

                    var changed = ApplyPresence(message);
                    if (changed)
                    {
                        var _ = BroadcastSnapshotAsync();
                    }
                }
            }
        }

        private static UdpClient CreateMulticastListener(IPEndPoint endpoint)
        {
            var udp = new UdpClient(AddressFamily.InterNetwork);
            udp.ExclusiveAddressUse = false;
            udp.Client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
            udp.Client.Bind(new IPEndPoint(IPAddress.Any, endpoint.Port));
            return udp;
        }

        private bool ApplyPresence(PresenceMessage message)
        {
            var now = DateTime.UtcNow;
            var changed = false;
            lock (rosterGate)
            {
                switch (message.Kind)
                {
                    case PresenceOpcode.Hello:
                    case PresenceOpcode.Heartbeat:
                        PresenceRecord existing;
                        if (!roster.TryGetValue(message.ClientId, out existing))
                        {
                            changed = true;
                        }
                        else if (!string.Equals(existing.DisplayName, message.DisplayName, StringComparison.OrdinalIgnoreCase) || existing.CameraEnabled != message.CameraEnabled || existing.IsSpeaking != message.IsSpeaking)
                        {
                            changed = true;
                        }

                        roster[message.ClientId] = new PresenceRecord(message.ClientId, message.DisplayName, message.CameraEnabled, message.IsSpeaking, now);
                        break;
                    case PresenceOpcode.Goodbye:
                        changed = roster.Remove(message.ClientId);
                        break;
                }
            }

            if (changed)
            {
                BeginInvoke(new Action(UpdateRosterList));
                Log(string.Format("[INFO] Presence updated by {0}", message.DisplayName));
            }

            return changed;
        }

        private async Task BroadcastSnapshotAsync()
        {
            if (snapshotSender == null)
            {
                return;
            }

            await snapshotLock.WaitAsync().ConfigureAwait(false);
            try
            {
                PresenceRecord[] snapshot;
                lock (rosterGate)
                {
                    snapshot = roster.Values.ToArray();
                }

                var envelope = PresenceMessage.CreateSnapshot(snapshot);
                var payload = envelope.ToPacket();
                await snapshotSender.SendAsync(payload, payload.Length, controlEndpoint).ConfigureAwait(false);
                lastSnapshotUtc = DateTime.UtcNow;
                snapshotsBroadcast++;
            }
            catch (ObjectDisposedException)
            {
            }
            catch (Exception ex)
            {
                Log("[ERROR] Snapshot broadcast: " + ex.Message);
            }
            finally
            {
                snapshotLock.Release();
            }
        }

        private void StartRelayServices()
        {
            if (relayToken != null)
            {
                return;
            }

            relayToken = new CancellationTokenSource();
            var token = relayToken.Token;

            try
            {
                videoRelayReceiver = CreateRelayReceiver(MulticastChannels.VIDEO_PORT);
                chatRelayReceiver = CreateRelayReceiver(MulticastChannels.CHAT_PORT);
                audioRelayReceiver = CreateRelayReceiver(MulticastChannels.AUDIO_PORT);

                videoRelaySender = CreateRelaySender(MulticastChannels.BuildVideoEndpoint().Address);
                chatRelaySender = CreateRelaySender(MulticastChannels.BuildChatEndpoint().Address);
                audioRelaySender = CreateRelaySender(MulticastChannels.BuildAudioEndpoint().Address);

                videoRelayTask = StartRelayLoop(videoRelayReceiver, videoRelaySender, MulticastChannels.BuildVideoEndpoint(), "Video", token);
                chatRelayTask = StartRelayLoop(chatRelayReceiver, chatRelaySender, MulticastChannels.BuildChatEndpoint(), "Chat", token);
                audioRelayTask = StartRelayLoop(audioRelayReceiver, audioRelaySender, MulticastChannels.BuildAudioEndpoint(), "Audio", token);

                Log("[INFO] Relay services started.");
            }
            catch (Exception ex)
            {
                Log("[ERROR] Unable to start relay services: " + ex.Message);
                StopRelayServices();
            }
        }

        private void StopRelayServices()
        {
            if (relayToken == null)
            {
                return;
            }

            relayToken.Cancel();

            CloseRelayClient(ref videoRelayReceiver);
            CloseRelayClient(ref chatRelayReceiver);
            CloseRelayClient(ref audioRelayReceiver);
            CloseRelayClient(ref videoRelaySender);
            CloseRelayClient(ref chatRelaySender);
            CloseRelayClient(ref audioRelaySender);

            WaitRelayTask(videoRelayTask);
            WaitRelayTask(chatRelayTask);
            WaitRelayTask(audioRelayTask);

            relayToken.Dispose();
            relayToken = null;
            videoRelayTask = null;
            chatRelayTask = null;
            audioRelayTask = null;
            Log("[INFO] Relay services stopped.");
        }

        private static UdpClient CreateRelayReceiver(int port)
        {
            var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
            socket.Bind(new IPEndPoint(IPAddress.Any, port));
            
            var udp = new UdpClient();
            udp.Client = socket;
            udp.Client.ReceiveTimeout = 1000;
            
            return udp;
        }

        private static UdpClient CreateRelaySender(IPAddress multicastAddress)
        {
            var socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
            socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
            socket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.MulticastTimeToLive, 32);
            socket.Bind(new IPEndPoint(IPAddress.Any, 0));
            
            var udp = new UdpClient();
            udp.Client = socket;
            udp.MulticastLoopback = true;
            udp.JoinMulticastGroup(multicastAddress);
            
            return udp;
        }

        private Task StartRelayLoop(UdpClient receiver, UdpClient sender, IPEndPoint target, string label, CancellationToken token)
        {
            return Task.Run(async () =>
            {
                while (!token.IsCancellationRequested)
                {
                    UdpReceiveResult result;
                    try
                    {
                        var receiveTask = receiver.ReceiveAsync();
                        var delayTask = Task.Delay(500, token);
                        var completedTask = await Task.WhenAny(receiveTask, delayTask).ConfigureAwait(false);
                        
                        if (completedTask == delayTask)
                        {
                            continue;
                        }
                        
                        result = await receiveTask.ConfigureAwait(false);
                    }
                    catch (ObjectDisposedException)
                    {
                        break;
                    }
                    catch (SocketException ex)
                    {
                        if (token.IsCancellationRequested)
                        {
                            break;
                        }
                        Log("[ERROR] " + label + " relay receive: " + ex.Message);
                        continue;
                    }
                    catch (Exception ex)
                    {
                        if (token.IsCancellationRequested)
                        {
                            break;
                        }
                        Log("[ERROR] " + label + " relay receive: " + ex.Message);
                        continue;
                    }

                    List<IPEndPoint> clients;
                    lock (rosterGate)
                    {
                        clients = clientEndpoints.Values.ToList();
                    }

                    foreach (var client in clients)
                    {
                        try
                        {
                            var unicastTarget = new IPEndPoint(client.Address, target.Port);
                            await sender.SendAsync(result.Buffer, result.Buffer.Length, unicastTarget).ConfigureAwait(false);
                        }
                        catch (ObjectDisposedException)
                        {
                            break;
                        }
                        catch (Exception ex)
                        {
                            Log("[ERROR] " + label + " relay send to " + client.Address + ": " + ex.Message);
                        }
                    }
                }
            }, token);
        }

        private void CloseRelayClient(ref UdpClient client)
        {
            if (client == null)
            {
                return;
            }

            try
            {
                client.Client?.Close();
                client.Close();
                client.Dispose();
            }
            catch
            {
            }
            
            client = null;
        }

        private void WaitRelayTask(Task task)
        {
            if (task == null)
            {
                return;
            }

            if (task.IsCompleted)
            {
                return;
            }

            task.Wait(50);
        }

        private bool CleanupInactiveClients()
        {
            var removed = new List<Guid>();
            var now = DateTime.UtcNow;
            lock (rosterGate)
            {
                foreach (var pair in roster)
                {
                    if (now - pair.Value.LastSeenUtc > TimeSpan.FromSeconds(12))
                    {
                        removed.Add(pair.Key);
                    }
                }

                foreach (var clientId in removed)
                {
                    roster.Remove(clientId);
                    clientEndpoints.Remove(clientId);
                }
            }

            if (removed.Count > 0)
            {
                BeginInvoke(new Action(UpdateRosterList));
                Log(string.Format("[WARN] Removed {0} inactive clients.", removed.Count));
            }

            return removed.Count > 0;
        }

        private void UpdateRosterList()
        {
            if (InvokeRequired)
            {
                BeginInvoke(new Action(UpdateRosterList));
                return;
            }

            if (listClients == null)
            {
                return;
            }

            listClients.BeginUpdate();
            listClients.Items.Clear();
            IEnumerable<PresenceRecord> ordered;
            lock (rosterGate)
            {
                ordered = roster.Values.OrderBy(r => r.DisplayName).ToArray();
            }

            foreach (var record in ordered)
            {
                var status = record.CameraEnabled
                    ? (record.IsSpeaking ? "Speaking" : "Camera ON")
                    : "Camera OFF";
                listClients.Items.Add(string.Format("{0} â€” {1}", record.DisplayName, status));
            }

            listClients.EndUpdate();
        }

        private async void OnMetricsTick(object sender, EventArgs e)
        {
            var removed = CleanupInactiveClients();
            if (removed || ShouldPushHeartbeat())
            {
                await BroadcastSnapshotAsync().ConfigureAwait(false);
            }

            UpdateMetrics();
        }

        private bool ShouldPushHeartbeat()
        {
            if (snapshotSender == null)
            {
                return false;
            }

            var now = DateTime.UtcNow;
            return lastSnapshotUtc == DateTime.MinValue || now - lastSnapshotUtc >= TimeSpan.FromSeconds(3);
        }

        private void UpdateMetrics()
        {
            if (InvokeRequired)
            {
                BeginInvoke(new Action(UpdateMetrics));
                return;
            }

            var now = DateTime.UtcNow;
            var lastSnapshotText = lastSnapshotUtc == DateTime.MinValue ? "-" : string.Format("{0:F1}s ago", (now - lastSnapshotUtc).TotalSeconds);
            var onlineCount = 0;
            lock (rosterGate)
            {
                onlineCount = roster.Count;
            }

            if (lblFrames != null)
            {
                lblFrames.Text = string.Format("Online: {0}", onlineCount);
            }

            if (lblBitrate != null)
            {
                lblBitrate.Text = string.Format("Snapshots: {0}", snapshotsBroadcast);
            }

            if (lblErrors != null)
            {
                lblErrors.Text = string.Format("Last push: {0}", lastSnapshotText);
            }
        }

        private void Log(string message)
        {
            if (InvokeRequired)
            {
                BeginInvoke(new Action(() => Log(message)));
                return;
            }

            listEvents.Items.Insert(0, string.Format("{0:HH:mm:ss} {1}", DateTime.Now, message));
            while (listEvents.Items.Count > 100)
            {
                listEvents.Items.RemoveAt(listEvents.Items.Count - 1);
            }
        }

        protected override void OnFormClosing(FormClosingEventArgs e)
        {
            StopPresenceService();
            base.OnFormClosing(e);
        }
    }
}
